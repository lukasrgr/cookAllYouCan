var Future = require("async-future")
var Style = require("Style")
var Block = require("Components/Block")

// compares arrays and objects for value equality (all elements and members must match)
exports.equal = function(a,b) {
    if(a instanceof Array) {
        if(!(b instanceof Array))
            return false
        if(a.length !== b.length) {
            return false
        } else {
            return a.reduce(function(previousValue, currentValue, index) {
                return previousValue && exports.equal(currentValue,b[index])
            }, true)
        }
    } else if(a instanceof Object) {
        if(!(b instanceof Object))
            return false

        var aKeys = Object.keys(a)
        var bKeys = Object.keys(b)

        if(aKeys.length !== bKeys.length) {
            return false
        } else {
            for(var n=0; n<aKeys.length; n++) {
                var key = aKeys[n]
                var aVal = a[key]
                var bVal = b[key]

                if(!exports.equal(aVal,bVal)) {
                    return false
                }
            }
            // else
            return true
        }
    } else {
        return a===b
    }
}


// slightly better than sequence, you define the functions up front, and when you call the return value, it passes the arguments you call it with to the functions in sequence
// returns a function that, each time its called, calls the next function in the list with the passed argument
// example:
/*
var sequenceX = testUtils.seq(
 function(x) {
     t.ok(x === 'a')
 },
 function(x) {
     t.ok(x === 'b')
 },
 function(x) {
     t.ok(x === 'c')
})

 var obj = {a:1,b:2,c:3}
 for(var x in obj) {
     sequenceX(x)
 }
 */
exports.seq = function (/*functions*/) {
    var n=-1
    var fns = arguments
    return function() {
        n++
        if(n>=fns.length)
            throw new Error("Unexpected call "+n+". Arguments: "+Array.prototype.slice.call(arguments))
        // else
        fns[n].apply(this,arguments)
    }
}


exports.demo = function(name, component) {
    var header = document.createElement("h2")
        header.textContent = name

    $("#demos").append(header);
    component.attach($("#demos")[0])

    return [header, component]
}
exports.cleanupDemo = function(nodes) {
    $(nodes[0]).remove()
    nodes[1].detach()
}
exports.manualDemo = function(name, component) {
    var header = document.createElement("h2")
        header.textContent = name

    $("#manualDemos").append(header);
    component.attach($("#manualDemos")[0])
}
exports.textOutput = function(name, textContent) {
    var header = document.createElement("h2")
        header.textContent = name

    var text = document.createElement("div")
        text.textContent = textContent

    $("#results").append([header, text]);
}

// future wraps a function like: function(result) {}
exports.wrapSingleParameter = function() {
    if(arguments.length === 1) {
        var fn = arguments[0]
    } else {
        var object = arguments[0]
        var method = arguments[1]
        var fn = object[method]
    }

    return function() {
        var args = Array.prototype.slice.call(arguments)
		var future = new Future
		args.push(function(result) {
		    future.return(result)
		})
		var me = this
        if(object) me = object
        fn.apply(me, args)
		return future
    }
}

exports.performanceTest = function(name, testDefinition) {
    setTimeout(function() {
        var times = []
        var totalTime = 0
        while(totalTime < 2000) {
            var time = oneIteration()
            times.push(time)
            totalTime += time
        }

        var averageTime = totalTime/times.length
        var stdDeviationPercentage = standardDeviation(times)/averageTime

        //console.log(mean(times)+ ' vs '+averageTime) // these should be equal and looks like they are
        exports.textOutput(name, Math.round(averageTime)+'ms (averaged over '+times.length+" iterations) - standard deviation: "+Math.round(stdDeviationPercentage*100)/100+'%')


        function oneIteration() {
            var time;
            testDefinition.call({
                time: function(testFn) {
                    var start = performance.now()
                    testFn()
                    time = performance.now() - start // ms
                }
            })

            return time
        }
    },0)
}

function standardDeviation(numberSet) {
    return Math.sqrt(variance(numberSet))
}

function variance(numberSet) {
    var theMean = mean(numberSet)
    var sumOfDifferenceSquares = numberSet.reduce(function(acc,x) {
        var difference = x-theMean
        return acc + difference*difference
    },0)

    return sumOfDifferenceSquares / (numberSet.length-1)
}

function mean(numberSet) {
    var sum = numberSet.reduce(function(acc,x) {
        return acc+x
    },0)

    return sum/numberSet.length
}


exports.buildNestedStructure = function (nestings) {
    var innerMost = Block()
    var cur = innerMost
    for(var n=0; n<nestings; n++) {
        cur = Block('moose', [cur])
    }
    return {innerMost:innerMost, top: cur}
}

exports.buildNestedStyle = function(nestings) {
    var styleObject = {};
    for(var n=0; n<nestings; n++) {
        styleObject = {color: 'red', Block: styleObject}
    }

    return Style(styleObject)
}