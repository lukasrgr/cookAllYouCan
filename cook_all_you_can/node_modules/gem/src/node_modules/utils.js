// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)

//require('hashmap') // here to mark hashmapMerge's dependency on this module
var path = require('path')


// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
// any number of objects can be passed into the function and will be merged into the first argument in order
// returns obj1 (now mutated)
var merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){
    return mergeInternal(arrayify(arguments), false)
}

// like merge, but traverses the whole object tree
// the result is undefined for objects with circular references
var deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {
    return mergeInternal(arrayify(arguments), true)
}

// merges two hashmaps together just like merge does for regular objects
// non-deep merge
exports.hashmapMerge = function(obj1, obj2/*, moreObjects...*/) {
    obj2.forEach(function(value, key) {
        obj1.set(key, obj2.get(key))
    })

    if(arguments.length > 2) {
        var newObjects = [obj1].concat(Array.prototype.slice.call(arguments, 2))
        return exports.hashmapMerge.apply(this, newObjects)
    } else {
        return obj1
    }
}

// returns a new object where properties of b are merged onto a (a's properties may be overwritten)
exports.objectConjunction = function(a, b) {
    var objectCopy = {}
    merge(objectCopy, a)
    merge(objectCopy, b)
    return objectCopy
}

// turns an array of values into a an object where those values are all keys that point to 'true'
exports.arrayToMap = function(array) {
    var result = {}
    array.forEach(function(v) {
        result[v] = true
    })
    return result
}

function mergeInternal(objects, deep) {
    var obj1 = objects[0]
    var obj2 = objects[1]

    for(var key in obj2){
       //if(Object.hasOwnProperty.call(obj2, key)) {
            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {
                mergeInternal([obj1[key], obj2[key]], true)
            } else {
                obj1[key] = obj2[key]
            }
       //}
    }

    if(objects.length > 2) {
        var newObjects = [obj1].concat(objects.slice(2))
        return mergeInternal(newObjects, deep)
    } else {
        return obj1
    }
}


function arrayify(a) {
    return Array.prototype.slice.call(a, 0)
}
