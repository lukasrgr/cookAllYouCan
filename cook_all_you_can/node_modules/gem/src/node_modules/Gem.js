var EventEmitterB = require('emitter-b')
var proto = require("proto");
var trimArguments = require("trimArguments")
var observe = require('observe')

var utils = require('./utils')
var domUtils = require('./domUtils')
var blockStyleUtils = require("./blockStyleUtils")

var devFlag = require("devFlag")

var Style = require("./Style")
Style.isDev = function() {return devFlag.dev}

var components = {};

var setOfBrowserEvents = utils.arrayToMap([
    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',
    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',
    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',
    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',
    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',
    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',
    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',
    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',
    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',
    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',
    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',
    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',
    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'
])

// events:
    // newParent - emits this when a component gets a new parent
    // parentRemoved - emits this when a component is detached from its parent
var Gem = module.exports = proto(EventEmitterB,function(superclass) {

    // static properties

    this.name = 'Gem'

    // constructor
	this.init = function() {
        var that = this

        if(this.name === 'Gem') {
            throw new Error("The 'name' property is required for Gem (it must be set to something that isn't 'Gem')")
        }

        superclass.init.call(this)

        this.attached = false
        if(this.children === undefined) this.children = [] // allow inheriting objects to create their own children array before calling this constructor
        this.state = observe({})
        this.parent = undefined;
        this._styleSetupInfo = []
        this._nativePseudoclassMap = {}

		if (this.id !== undefined) {
			components[this.id] = this;
		}

        if(this.domNode === undefined) {
            this.domNode = domUtils.div()
        }
                
        // quiet.focus property
        this.quiet = {}
        setupFocusProperty(this, true)

        this.build.apply(this, arguments)

        //if(devFlag.dev) {
            this.attr('gem', this.name)
        //}


        this.domNode.className += ' '+Style.defaultClassName // add the default class
        /*if(this._style === undefined) { // if a style wasn't set by this.build
            this.style = undefined // initialize style to its gem or inherited default
        }*/

        // set up dom event handlers
        var ifonHandlers={}
        that.ifon(function(event) {
            ifOnBrowserEvent(that, that, event, ifonHandlers)
        })
        that.ifoff(function(event) {
            ifOffBrowserEvent(that, event, ifonHandlers)
        })

        this.ifonCaptureHandlers={}, this.ifonCaptureHandlerCounts={}
        this.captureEmitter = new EventEmitterB()
	}

    // sub-constructor - called by the constructor
    // can be overridden as a constructor that requires less boilerplate
    this.build = function() {}


	// instance properties


	this.domNode;
    this.label;        // a static label that can be used for styling
    this.excludeDomEvents;
    this.children;     // a list of child components that are a part of a Gem object (these are used so Styles can be propogated down to child components)


    Object.defineProperty(this, 'label', {
        get: function() {
            return this._label
        }, set: function(v) {
            if(this._label === undefined) {
                this._label = v

                //if(devFlag.dev) {
                    this.attr('label', this._label)
                //}
            } else {
                throw new Error("A Gem's label can only be set once (was already set to: "+this._label+")")
            }
        }
    })

    // adds elements to the components main domNode
    // arguments can be one of the following:
        // component, component, component, ...
        // listOfGems
    this.add = function() {
        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))
	}

    // adds nodes at a particular index
    // nodes can be one of the following:
        // component, component, component, ...
        // listOfGems
    // todo: look into using document fragments to speed this up when multiple nodes are being added
    this.addAt = function(index/*, nodes...*/) {
        var nodes = normalizeAddAtArguments.apply(this, arguments)

        for (var i=0;i<nodes.length;i++) {
			var node = nodes[i];

            // remove the node from its current parent if necessary
            if(node.parent !== undefined) {
                throw new Error('Node at index '+i+' already has a parent. Remove the node from its parent before adding it somewhere else.')
            }
            if(!isGem(node)) {
                throw new Error("node is not a Gem")
            }
                                     
            this.children.splice(index+i, 0, node)
            
            var beforeChild = this.children[1+i+index]
            if(beforeChild === undefined) {
                this.domNode.appendChild(node.domNode)
            } else {
                this.domNode.insertBefore(node.domNode, beforeChild.domNode)
            }
            

            node.parent = this;
            node.emit('newParent')
		}

        if(this.attached) {
            for (var i=0;i<nodes.length;i++) {
                var node = nodes[i]
                blockStyleUtils.setAttachStatus(node,true) // must be done before setting the style (unsure why at the moment)
                node.style = node._style // rerender its style
            }
        }
    }

	// add a list of nodes before a particular node
    // if beforeChild is undefined, this will append the given nodes
    // arguments can be one of the following:
        // component, component, component, ...
        // listOfGems
    this.addBefore = this.addBeforeNode = function(beforeChild) {
        var nodes = trimArguments(arguments).slice(1)
        if(beforeChild === undefined) {
            this.add.apply(this, nodes)
        } else {
            var index = this.children.indexOf(beforeChild)
            this.addAt.apply(this, [index].concat(nodes))
        }
    }


    // arguments can be one of the following:
        // component, component, component, ...
        // index, index, index, ... - each index is the numerical index to remove
        // arrayOfComponents
        // arrayOfIndexes
    this.remove = function() {
        var removals = normalizeRemoveArguments.apply(this, arguments)
        removals = removals.sort(function(a,b) {
            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)
        })

        for(var n=0; n<removals.length; n++) {
            var r = removals[n]
            var c = this.children[r]

            if(c === undefined) {
                throw new Error("There is no child at index "+r)
            }

            c.parent = undefined
            this.children.splice(r, 1)
            this.domNode.removeChild(this.domNode.childNodes[r])

            c.emit('parentRemoved')
            if(this.attached) {
                c.emit("detach")
            }
        }
    }

    // sets or gets an attribute on the components domNode
    // parameter sets:
    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)
    // if there are two arguments passed, the attribute is set
        // if 'value' is undefined, the attribute is removed
    this.attr = function(/*attribute, value OR attributeObject*/) {
        if(arguments.length === 1) {
            if(arguments[0] instanceof Object) {
                var attributes = arguments[0]
                for(var attribute in attributes) {
                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])
                }
            } else {
                var attribute = this.domNode.getAttribute(arguments[0])
                if(attribute === null) {
                    return undefined // screw null
                } else {
                    return attribute
                }
            }
        } else {
            var attribute = arguments[0]
            if(arguments[1] !== undefined) {
                var value = arguments[1]
                domUtils.setAttribute(this.domNode, arguments[0], value)
            } else {
                this.domNode.removeAttribute(attribute)
            }
        }
    }

    Object.defineProperty(this, 'visible', {
        // returns true if the element is visible
        get: function() {
            return this.domNode.style.display !== 'none';

        // sets whether or not the element is visible
        }, set: function(setToVisible) {
            if(setToVisible) {
                if (this._displayStyle !== undefined) {
                    this.domNode.style.display = this._displayStyle // set back to its previous inline style
                    this._displayStyle = undefined
                } else {
                    this.domNode.style.display = ''
                }
            } else {
                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style
                    this._displayStyle = this.domNode.style.display
                }

                this.domNode.style.display = 'none'
            }
        }
    })

    // focus property
    setupFocusProperty(this, false)

    Object.defineProperty(this, 'style', {
        get: function() {
            return this._style

        // sets the style, replacing one if one already exists
        }, set: function(style) {
            // get active style
                // mix the gem-default style with ..
                // .. the current style
                // .. style returned by the $state of current style
                // .. $$pseudoclasses of current + $state styles

            if(style === undefined || blockStyleUtils.isStyleObject(style)) {
                this._style = style
            } else {
                this._style = Style(style)
            }

            if(this.attached) {
                var newStyle = getStyle(this)  // must be called after setting _style
                var defaultStyle = this.getDefaultStyle()

                var newCurrentStyle = blockStyleUtils.mixStyles(defaultStyle, newStyle)
                blockStyleUtils.setCurrentStyle(this, newCurrentStyle, defaultStyle)
            }
        }
    })

    Object.defineProperty(this, 'selectionRange', {
        // returns the visible character selection range inside the element
        // returns an array like [offsetStart, offsetEnd]
        get: function() {
            return domUtils.getSelectionRange(this.domNode)

        // sets the visible character selection range
        }, set: function(selection) {
            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])
        }
    })

    this.attach = function(domNode) {
        if(domNode !== undefined)
            attach(domNode, this)
        else
            attach(this)
    }
    this.attachBefore = function(domNode) {
        if(domNode !== undefined)
            attachInternal([domNode,this], true)
        else
            attachInternal([this], true)
    }
    this.detach = function(domNode) {
        if(domNode !== undefined)
            detach(domNode, this)
        else
            detach(this)
    }

    this.onCapture = function(event, handler) {
        if(!(event in this.ifonCaptureHandlers)) {
            ifOnBrowserEvent(this, this.captureEmitter, event, this.ifonCaptureHandlers, true)
        }

        this.ifonCaptureHandlerCounts[event]++
        this.captureEmitter.on(event, handler)
    }
    this.offCapture = function(event, handler) {
        this.ifonCaptureHandlerCounts[event]--
        this.captureEmitter.off(event, handler)
        if(this.ifonCaptureHandlerCounts[event] === 0) {
            ifoffBrowserEvent(this, event, this.ifonCaptureHandlers, true)
        }
    }

    this.proxy = function(emitter, options) {
        if(options === undefined) options = {except:[]}
        if(options.except !== undefined) {
            options.except = options.except.concat(['newParent','parentRemoved'])
        }

        return superclass.proxy.apply(this,[emitter,options])
    }


	// private instance variables/functions

    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components
    this._nativePseudoclassMap; // a map of Gem names to a set of native pseudoclass styles and their css selector base (eg: {GemA: {'.style1:required .style2': styleObject}}

	this._style;             // the object's explicit Style object (undefined if it inherits a style)
    this._currentStyle;      // the object's current Style that will only change if its parent's activeStyle changes, or if a style is explicitly reset on the gem
    this._activeStyle;       // the active style depending on pseudoclasses, $state, and defaultStyle

    this._displayStyle;      // temporarily stores an inline display style while the element is hidden (for use when 'show' is called)
    this._styleSetupInfo   // place to put states for setup functions (used for css pseudoclass emulation)
    this._stateChangeHandler // the handler being used for $state style changes

    this.attached           // set to true if the gem has been attached to the document (or if one of its ancestors has been)


    // returns the default style of the current Gem based on the 'defaultStyle' property set on its constructor (this.constructor)
    // if there is more than one default style, they are merged in order
    // if there is no default style, undefined is returned
    this.getDefaultStyle = function() {
        return blockStyleUtils.getDefaultStyle(this)
    }

    // gets the high-level style of the gem, either from the gem's explicit style, or inherits from its parent's style map
    function getStyle(gem) {
        if(gem._style !== undefined) {            // use the gem's explicit style if possible
            if(gem._style.inherit) {
                var styleToInerit = blockStyleUtils.getInheritingStyle(gem)
                if(styleToInerit !== undefined)
                    return styleToInerit.mix(gem._style, false)
            }
            // else
            return gem._style

        } else {     // otherwise use the parent's computedStyleMap
            return blockStyleUtils.getInheritingStyle(gem)
        }
    }

    function setupFocusProperty(that, quiet) {
         // returns true if the element is in focus
        var getFn = function() {
            return document.activeElement === this.domNode
        }

        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)
        var setFn = function(setToInFocus) {
            if(quiet)
                this.quietFocus = true

            if(setToInFocus) {
                this.domNode.focus()
            } else {
                this.domNode.blur()
            }
        }

        if(quiet) {
            var container = that.quiet
            getFn = getFn.bind(that)
            setFn = setFn.bind(that)
        } else {
            var container = that
        }

        Object.defineProperty(container, 'focus', {get: getFn, set: setFn})
    }

    // should only be called on the first 'on' for each event
    function ifOnBrowserEvent(that, emitter, event, handlerCache, capture) {
        if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {
            that.domNode.addEventListener(event, handlerCache[event]=function() {
                if(event === 'focus' && that.quietFocus) return // shhh
                emitter.emit.apply(emitter, [event].concat(Array.prototype.slice.call(arguments)))
            },capture)
        }
    }
    // should only be called on the last 'off' for each event
    function ifOffBrowserEvent(that, event, handlerCache,capture) {
        if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {
            that.domNode.removeEventListener(event,handlerCache[event],capture)
        }
    }
});


Object.defineProperty(module.exports, 'dev', {
    get: function() {
        return devFlag.dev
    }, set: function(v) {
        devFlag.dev = v
    }
})

// appends components to the passed domNode (default: body)
var attach = module.exports.attach = function(/*[domNode,] component or components*/) {
    attachInternal(arguments, false)
}

// appends components immediately before the passed domNode
module.exports.attachBefore = function(/*[domNode,] component or components*/) {
    attachInternal(arguments, true)
}

// removes components from their parents
var detach = module.exports.detach = function(components) {
    if(!(components instanceof Array)) {
        components = [components]
    }

    for(var n=0; n<components.length; n++) {
        var gem = components[n]
        gem.domNode.parentNode.removeChild(gem.domNode)

        blockStyleUtils.setAttachStatus(gem, false)
    }
}

// creates a body tag (only call this if document.body is null)

module.exports.createBody = function(callback) {
    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);
    var body = dom.createElement("body")
    dom.documentElement.appendChild(body)
    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler
        callback()
    },0)
}


function attachInternal(args, before) {
    if(args.length > 1) {
        var domNode = args[0]
        var components = args[1]
    } else {
        if(document.body === null) throw new Error("Your document does not have a body.")
        var domNode = document.body
        var components = args[0]
    }

    if(!(components instanceof Array)) {
        var components = [components]
    }

    for(var n=0; n<components.length; n++) {
        if(before) {
            domNode.parentNode.insertBefore(components[n].domNode, domNode)
        } else {
            domNode.appendChild(components[n].domNode)
        }

        blockStyleUtils.setAttachStatus(components[n], true) // must be done before setting the style (unsure why at the moment)
        components[n].style = components[n]._style   // force style rendering
    }
}

// returns a list of indexes to remove from Gem.remove's arguments
/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {
    var that = this

    if(arguments[0] instanceof Array) {
        var removals = arguments[0]
    } else {
        var removals = Array.prototype.slice.call(arguments)
    }

    return removals.map(function(removal, parameterIndex) {
        if(isGem(removal)) {
            var index = that.children.indexOf(removal)
            if(index === -1) {
                throw new Error("The Gem passed at argument index "+parameterIndex+" is not a child of this Gem.")
            }
            return index
        } else {
            return removal
        }

    })
}

// returns a list of nodes to add
/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {
    if(arguments.length === 2) {
        if(arguments[1] instanceof Array) {
            return arguments[1]
        } else {
            return [arguments[1]]
        }
    } else { // > 2
        return trimArguments(arguments).slice(1)
    }
}

function isGem(c) {
    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined
}