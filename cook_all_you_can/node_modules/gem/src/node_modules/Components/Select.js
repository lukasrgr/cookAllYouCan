var Gem = require('../Gem')
var proto = require('proto')

var domUtils= require("domUtils")
var Option = require('Components/Option')

// emits a 'change' event when its 'val' changes
module.exports = proto(Gem, function(superclass) {

	// static variables

    this.name = 'Select'

    this.Option = Option

	this.init = function(/*[label,] options*/) {
        if(arguments[0] instanceof Object) {
            var options = arguments[0]
        } else {
            var label = arguments[0]
            var options = arguments[1]
        }

        this.domNode = document.createElement("select") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it
        this.label = label

        this.children = [] // need children before calling add
        this.options = {}
		for(var value in options) {
			this.option(value, options[value])
		}

        superclass.init.apply(this, arguments) // superclass constructor       
           
        domUtils.setupBoundProperty(this,this.quiet,'val', {
            getFn: getVal, 
            setFn: function(x) {
                setVal.bind(this)(x, true)   
            }
        })
	}


	// instance methods

    Object.defineProperty(this, 'val', {
        get: getVal, set: setVal
    })
    // returns the value that is selected
    function getVal() {
        for(var value in this.options) {
            if(this.options[value].selected) {
                return this.options[value].val
            }
        }
    }
    function setVal(value, quiet) {
        var option = this.options[value]
        if(option === undefined || option.val !== value) throw new Error("There is no Option in the Select with the value: '"+value+"'")
        if(quiet) option = option.quiet
        option.selected = true
    }
	
	this.option = function(/*[label,] value,text*/) {
        if(arguments.length === 2) {
            var value = arguments[0]
            var text = arguments[1]
        } else if(arguments.length === 3) {
            var label = arguments[0]
            var value = arguments[1]
            var text = arguments[2]
        } else {
            throw new Error("Invalid number of arguments")
        }

        var newOption = Option(label, value,text)
        this.add(newOption)

        return newOption

	}

    // same interface as Gem.addAt
    /*override*/ this.addAt = function(index/*, nodes...*/) {
        var that = this

        var nodesToAdd = Gem.normalizeAddAtArguments.apply(this, arguments)

        // validation first
        nodesToAdd.forEach(function(option) {
            if(that.options[option.val] !== undefined) {
                throw new Error("Can't give an Option the same value as another in the Select (value: '"+option.val+"')")
            }
        })

        superclass.addAt.call(this, index, nodesToAdd)

        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it
        var anyWereSelected = false
        nodesToAdd.forEach(function(option) {
            if(option.selected) anyWereSelected = true
            that.options[option.val] = option

            // set up Select events
            // todo: remove events when the Option is removed

            option.on("mousedown",function(event) {
                option.parent.val = option.val      // select this one
            })
        })

        if(anyWereSelected) {
            this.emit('change')
        }
    }

    // same interface as Gem.remove
    /*override*/ this.remove = function() {
        var that = this

        var removalIndexes = Gem.normalizeRemoveArguments.apply(this, arguments)
        var removals = removalIndexes.map(function(index) {
            return that.children[index]
        })

        superclass.remove.call(this, removalIndexes)

        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it
        var theSelectedWasRemoved = false
        removals.forEach(function(option) {
            if(option.selected) theSelectedWasRemoved = true
            delete that.options[option.val]
        })

        if(theSelectedWasRemoved) {
            //this.children[0].selected = true // I think the browser does this automatically??
            this.emit('change')
        }
    }


    // private

    this.prepareForValueChange = function(values, quiet) {
        var value = values[0]

        for(var optionValue in this.options) {
            if(optionValue !== value) {
                var option = this.options[optionValue]
                if(option.selected === true) {
                    option.domNode.selected = false
                    if(!quiet) option.emit('change')
                }
            }
        }
    }
})

