var Gem = require('../Gem')
var proto = require('proto')

var Option = require('Components/Option')

// emits a 'change' event when its 'val' changes
module.exports = proto(Gem, function(superclass) {

	// static variables

    this.name = 'MultiSelect'

    this.Option = Option

	this.init = function(/*[label,] options*/) {
        if(arguments[0] instanceof Object) {
            var options = arguments[0]
        } else {
            var label = arguments[0]
            var options = arguments[1]
        }

        this.domNode = document.createElement("select") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it
        this.attr('multiple','multiple')
        this.label = label

        this.options = {}

        this.children = [] // need children before calling add
		for(var value in options) {
			this.option(value, options[value])
		}

        /*
		var that = this
        that.domNode.addEventListener('mousedown', function() {
            console.log("parent mousedown")
            var enterHandler, upHandler;
            that.children.forEach(function(child) {
                child.domNode.addEventListener('mouseover', enterHandler = function() {
                    console.log("child mouseover")
                    child.selected = true
                })
            })

            that.domNode.addEventListener('mouseup', upHandler = function() {
                console.log("parent mouseup")
                that.children.forEach(function(child) {
                    child.domNode.removeEventListener('mouseover', enterHandler)
                })

                that.domNode.removeEventListener('mouseup', upHandler)
            })
        })*/

        superclass.init.apply(this, arguments) // superclass constructor
	}


	// instance methods

    Object.defineProperty(this, 'val', {
        // returns a list of the values that are selected
        get: function() {
            var result = []
            for(var value in this.options) {
                if(this.options[value].selected) {
                    result.push(value)
                }
            }

            return result
        },

        // values can either be an array, or a single value to select
        set: function(values) {
            if(!(values instanceof Array))
                values = [values]

            var that = this
            values.forEach(function(value) {
                if(that.options[value] === undefined) {
                    throw new Error("There is no Option in the MultiSelect with the value: '"+value+"'")
                }
            })

            var stringifiedValues = values.map(function(v){return v.toString()})

            var somethingChanged = false
            for(var value in this.options) {
                var selected = stringifiedValues.indexOf(value) !== -1
                var option = this.options[value]

                if(option.selected !== selected) {  // selected state change
                    somethingChanged = true
                    option.quiet.selected = selected
                    option.emit('change')
                }
            }

            if(somethingChanged) {
                this.emit('change')
            }
        }
    })
	
	this.option = function(/*[label,] value,text*/) {
        if(arguments.length === 2) {
            var value = arguments[0]
            var text = arguments[1]
        } else if(arguments.length === 3) {
            var label = arguments[0]
            var value = arguments[1]
            var text = arguments[2]
        } else {
            throw new Error("Invalid number of arguments")
        }

        var newOption = Option(label, value,text)
        this.add(newOption)

        return newOption

	}

    // same interface as Gem.addAt
    /*override*/ this.addAt = function(index/*, nodes...*/) {
        var that = this

        var nodesToAdd = Gem.normalizeAddAtArguments.apply(this, arguments)

        // validation first
        nodesToAdd.forEach(function(option) {
            if(that.options[option.val] !== undefined) {
                throw new Error("Can't give an Option the same value as another in the MultiSelect (value: '"+option.val+"')")
            }
        })

        superclass.addAt.call(this, index, nodesToAdd)

        // MultiSelect specific state modifications - this must be done after the superclass call in case an error is thrown from it
        var anyWereSelected = false
        nodesToAdd.forEach(function(option) {
            if(option.selected) anyWereSelected = true
            that.options[option.val] = option


            // set up multi-select events
            // todo: remove events when the Option is removed

            option.on("mousedown",function(event) {
                event.preventDefault()           // this needs to be here otherwise the options can't be deselected

                option.parent.focus = true // without this, the parent doesn't gain focus
                option.focus = true
                if(event.shiftKey || event.ctrlKey) {
                    option.selected = !option.selected // toggle
                } else {
                    var parentVal = option.parent.val
                    var onlyThisIsSelected = parentVal.length === 1 && parentVal[0] === option.val
                    if(onlyThisIsSelected) {
                        option.selected = false
                    } else {
                        option.parent.val = [option.val] // select only this one
                    }
                }
            })
            /*option.domNode.addEventListener("click",function(event) {
                //event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*
                option.emit('click', event)
            })*/
            option.on("mousemove",function(event) {
                event.preventDefault()         // this needs to be here otherwise the radio button is unset as soon as you move the mouse (when the mouse is down)
            })
            /*this.domNode.addEventListener("keydown",function(event) {
                if(event.keyCode === 40 || event.keyCode === 39) { // down or right
                    event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up
                    option.selectNext()
                } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left
                    event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up
                    option.selectPrevious()
                }
            })*/

            /*;['click', 'drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop', 'cancel',
                'mousedown', 'mouseenter', 'mousemove', 'mouseleave', 'mouseout', 'mouseover', 'mouseup'
            ].forEach(function(eventType) {
                option.domNode.addEventListener(eventType, function( event ) {
                    //event.preventDefault()
                    console.log(eventType)
                });
            })*/

        })

        if(anyWereSelected) {
            this.emit('change')
        }
    }

    // same interface as Gem.remove
    /*override*/ this.remove = function() {
        var that = this

        var removalIndexes = Gem.normalizeRemoveArguments.apply(this, arguments)
        var removals = removalIndexes.map(function(index) {
            return that.children[index]
        })

        superclass.remove.call(this, removalIndexes)

        // MultiSelect specific state modifications - this must be done after the superclass call in case an error is thrown from it
        var anyWereSelected = false
        removals.forEach(function(option) {
            if(option.selected) anyWereSelected = true
            delete that.options[option.val]
        })

        if(anyWereSelected) {
            this.emit('change')
        }
    }


    // private

    this.prepareForValueChange = function() {} // no-op
})

