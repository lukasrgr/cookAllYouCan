// note: this is  not intended to be used directly - only through Select and MultiSelect

var proto = require('proto')

var Gem = require('Gem')
var Style = require('Style')
var domUtils = require("domUtils")

// emits a 'change' event when its 'selected' value changes
module.exports = proto(Gem, function(superclass) {

    // staic members

    this.name = 'Option'

    this.defaultStyle = Style({
        display: 'block'
    })


    // instance members

    this.init = function(/*[label,] value, text*/) {
        this.domNode = document.createElement("option") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it

        if(arguments.length===2) {
            this.val = arguments[0]
            this.text = arguments[1]
        } else { // 3
            this.label = arguments[0]
            this.val = arguments[1]
            this.text = arguments[2]
        }

        superclass.init.apply(this, arguments) // superclass constructor   
           
        domUtils.setupBoundProperty(this,this.quiet,'selected', {
            getFn: getSelected, 
            setFn: function(x) {
                setSelected.bind(this)(x, true)   
            }
        })
        domUtils.setupBoundProperty(this,this.quiet,'val', {
            getFn: getVal, 
            setFn: function(x) {
                setVal.bind(this)(x, true)   
            }
        })
    }

    Object.defineProperty(this, 'val', {
        get:getVal, set:setVal
    })
    // returns the value of the Option
    function getVal() {
        return this._value
    }
    // sets the value of the Option
    function setVal(value, quiet) {
        if(this.parent !== undefined) {
            if(this.parent.options[value] !== undefined) {
                throw new Error("Can't give an Option the same value as another in the Select or MultiSelect (value: "+JSON.stringify(value)+")")
            }

            if(this.val !== null) {
                delete this.parent.options[this.val]
            }

            this.parent.options[value] = this
        }

        this._value = value

        if(this.selected && this.parent !== undefined && !quiet) {
            this.parent.emit('change')
        }
    }


    Object.defineProperty(this, 'selected', {
        get: getSelected, set: setSelected  
    })
    // returns whether or not the option is selected
    function getSelected() {
        return this.domNode.selected
    }
    // sets the selected state of the option to the passed value (true for selected)
    function setSelected(value, quiet) {
        var booleanValue = value === true
        if(this.selected === booleanValue) return false; // ignore if there's no change

        if(this.parent !== undefined)
            this.parent.prepareForValueChange([this.val], quiet)

        if(this.selected === booleanValue) return; // ignore if there's no change

        this.domNode.selected = booleanValue
        
        if(!quiet) {
            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property    
            if(this.parent !== undefined)
                this.parent.emit('change')
        }
    }

    Object.defineProperty(this, 'text', {
        get: function() {
            return this.domNode[domUtils.textProperty]
        },

        set: function(text) {
            this.domNode[domUtils.textProperty] = text
        }
    })


    // private

    // deprecated
    // does everything for setting the selected state except emit the parent's change event
    this.setSelectedQuiet = function setOptionSelected(booleanValue) {
        this.quiet.selected = booleanValue  
    }
})