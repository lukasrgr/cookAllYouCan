var proto = require('proto')
var EventEmitter = require('events').EventEmitter

var Gem = require('../Gem')
var domUtils = require("domUtils")

var randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)

// A group of radio buttons
module.exports = proto(EventEmitter, function(superclass) {

	// static properties

    this.name = 'Radio'

	// instance properties


    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.
	this.init = function(required) {
        //this.selected
        this.required = required === true || required === undefined
        this.buttons = {} // maps values to the buttons that have each value
        this.randomStart = randomStart++
        
        this.quiet = {}        
        domUtils.setupBoundProperty(this,this.quiet,'val', {
            getFn: getVal, 
            setFn: function(x) {
                setVal.bind(this)(x, true)   
            }
        })
	}

    // returns a new radio button
    this.button = function(/*[label,] value*/) {
        if(arguments.length >= 2) {
            var label = arguments[0]
            var value = arguments[1]
        } else {
            var value = arguments[0]
        }

        if(this.buttons[value] !== undefined) {
            throw new Error("Can't give a RadioButton the same value as another in the group (value: '"+value+"')")
        }

        var button = RadioButton(this, label, value, "_radioblock"+this.randomStart)
        this.buttons[value] = button

        if(this.required && this._selected === undefined) {
            button.selected = true
        }

        return button
    }

    // returns the RadioButton in the group that's selected (or undefined if none are selected)
    Object.defineProperty(this, 'selectedOption', {
        get: getSelectedOption, set: setSelectedOption
    })
    Object.defineProperty(this, 'selected', { // deprecated
        get: getSelectedOption, set: setSelectedOption
    })

    function getSelectedOption() {
        return this._selected
    }    
    function setSelectedOption() {
        throw new Error("Can't set selected on a Radio object")
    }

    Object.defineProperty(this, 'val', {        
        get: getVal, set: setVal
    })

    // returns the value of the selected radio button in the group (undefined if none are selected)
    function getVal() {
        var selected = this._selected
        if(selected === undefined) return undefined
        // else
        return selected.attr('value')
    }    
    // sets the value of the checkbox to the passed value (true for checked)
    // throws an exception if none of the radio buttons have that value
    // throws an exception if an unset is attempted for a required Radio set
    function setVal(value, quiet) {
        if(value === undefined) {
            var selected = this._selected
            if(selected !== undefined) {
                if(quiet) selected = selected.quiet
                selected.selected = false
            }
        } else {
            var button = this.buttons[value]
            if(button === undefined) throw new Error("There is no RadioButton in the group with the value: '"+value+"'")

            if(quiet) button = button.quiet
            button.selected = true
        }
    }
    

    // arguments can be one of the following:
        // RadioButton, RadioButton, RadioButton, ...
        // value, value, value, ... - each value is the value of the RadioButton to remove
        // arrayOfRadioButtons
        // arrayOfValues
    this.remove = function() {
        if(arguments[0] instanceof Array) {
            var removals = arguments[0]
        } else {
            var removals = arguments
        }

        for(var n=0; n<removals.length; n++) {
            var r = removals[n]

            if(r instanceof RadioButton) {
                var button = r
                var value = r.val

                if(this.buttons[value] !== r) {
                    throw new Error("The button passed at index "+n+" is not part of the group.")
                }
            } else {
                var button = this.buttons[r]
                var value = r

                if(button === undefined) {
                    throw new Error("There is no RadioButton in the group with the value: '"+value+"'")
                }
            }

            var originalSelected = this.selected
            if(this.selected === button) {
                this._selected = undefined
            }

            this.buttons[value].group = undefined // fully remove it from the group
            delete this.buttons[value]
        }

        if(this.required && this.selected === undefined) {
            for(var v in this.buttons) {
                this.buttons[v].selected = true // just select the first one
                break; // yes this doesn't loop
            }
        } else if(originalSelected !== this.selected) {
            this.emit('change')
        }
    }

})

var RadioButton = proto(Gem, function(superclass) {
    this.name = 'RadioButton'

    this.init = function(radioGroup, label, value, name) {
        this.domNode = document.createElement("input") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it
        superclass.init.call(this) // superclass constructor

        this.label = label
        this.group = radioGroup

        this.attr('type', 'radio')
        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups
        this.val = value
                        
        domUtils.setupBoundProperty(this,this.quiet,'selected', {
            getFn: getSelected, 
            setFn: function(x) {
                setSelected.bind(this)(x, true)   
            }
        })    
        domUtils.setupBoundProperty(this,this.quiet,'val', { // this is here just for consistency, it isn't different than button.val because button.val doesn't emit a change event
            getFn: getSelected, setFn: setSelected
        })

        var that = this
		this.on("mousedown",function(event) {
            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed

			if(that.group.required) {
                if(that.selected === false) {
                    that.selected = true
                }
            } else {
                that.selected = !that.selected // toggle
            }
		})
        this.on("click",function(event) {
            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*
        })
        this.on("keydown",function(event) {
            if(event.keyCode === 40 || event.keyCode === 39) { // down or right
                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up
                that.selectNext()
            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left
                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up
                that.selectPrevious()
            }
        })
    }

    Object.defineProperty(this, 'val', {
        // returns the value attribute of the checkbox
        get: function() {
            return this.attr('value')
        },

        // sets the value attribute of the checkbox
        set: function(value) {
            if(this.group.buttons[value] !== undefined) {
                throw new Error("Can't give a RadioButton the same value as another in the group (value: '"+value+"')")
            }

            var oldValue = this.val
            this.attr('value', value)
            if(oldValue !== undefined) delete this.group.buttons[oldValue]
            this.group.buttons[value] = this
        }
    })


    Object.defineProperty(this, 'selected', {
        get: getSelected, set: setSelected
    })

    this.selectNext = function() {
        selectSibling(this,1)
    }
    this.selectPrevious = function() {
        selectSibling(this,-1)
    }
    
    // returns whether or not the checkbox is checked
    function getSelected() {
        return this.domNode.checked
    }
    // sets the selected state of the checkbox to the passed value (true for checked)
    function setSelected(value, quiet) {
        var booleanValue = value === true
        if(this.selected === value) return; // ignore if there's no change

        if(booleanValue) {
            var previouslySelected = this.group.selected
            setButtonInGroup(this.group, this)
            if(previouslySelected !== undefined && !quiet)
                previouslySelected.emit('change')
        } else {
            if(this.group.required) throw new Error("Can't unset this Radio set, a value is required.")
            this.domNode.checked = false
            this.group._selected = undefined
        }
        
        if(!quiet) {
            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property
            this.group.emit('change')                        
        }
    }

})

// direction can be +1 or -1
function selectSibling(button, direction) {
    var buttons = button.group.buttons
    var values = Object.keys(buttons)
    var index = values.indexOf(button.attr('value'))
    if(direction === 1 && index === values.length-1) {
        var buttonToSelect = buttons[values[0]]
    } else if(direction === -1 && index === 0) {
        var buttonToSelect = buttons[values[values.length-1]]

    } else {
        var buttonToSelect = buttons[values[index+direction]]
    }

    buttonToSelect.selected = true
    buttonToSelect.focus()
}

function setButtonInGroup(group, button) {
    var selected = group._selected
    if(selected !== undefined) selected.domNode.checked = false
    button.domNode.checked = true
    group._selected = button
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}