// some functionality that is needed by Gem.js but is related to styling (some things are also needed by Style.js)

var HashMap = require("hashmap")

var Style = require("./Style")
var utils = require('./utils')

var defaultStyleMap = new HashMap() // maps from a proto class to its computed default style
var computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map


// gets the right style from the styleMap, depending on the gem's `name` and `label` (`label` styles take precedence)
// takes the component's inheritance tree into account (relies on the gem.constructor.parent property)
var getStyleMapEntryForGem = exports.getStyleForComponent = function (styleMap, gem) {
    if(styleMap === undefined)
        return undefined

    return getStyleForLabel(styleMap, gem) || getStyleForGemName(styleMap, gem)
}

var getStyleForLabel = exports.getStyleForLabel = function(styleMap, gem) {
    if(gem.label !== undefined && '$'+gem.label in styleMap) {
        return styleMap['$'+gem.label]
    }
}
var getStyleForGemName = exports.getStyleForBlockName = function(styleMap, gem) {
    var constructor = gem.constructor
    while(constructor !== undefined) {
        var style = styleMap[constructor.name]
        if(style !== undefined) {
            return style
        } else {
            constructor = constructor.parent
        }
    }
}

// gets the possibly inheriting style from the styleMap for `gem`
// gem - the gem to get the style for
// ancestor - the gem to get the computedStyleMap from
var getInheritingStyle = exports.getInheritingStyle = function(gem) {
    var ancestor = gem.parent
    if(ancestor === undefined || ancestor.computedStyleMap === undefined) return undefined

    if(gem.label !== undefined) {
        var styleMapKey = '$'+gem.label
        var nextContructor = gem.constructor
    } else {
        var styleMapKey = gem.constructor.name
        var nextContructor = gem.constructor.parent
    }

    var nextAncestorToSearchFrom = ancestor
    var styles = [], inherit = true
    while(nextAncestorToSearchFrom !== undefined) {    // find styles from the most specific name to the least specific
        var stylesForKey = findStylesForStyleMapKey(nextAncestorToSearchFrom, styleMapKey)
        styles = styles.concat(stylesForKey.styles)
        nextAncestorToSearchFrom = stylesForKey.nextAncestorToSearchFrom
        inherit = stylesForKey.inherit

        if(nextContructor === undefined || !inherit) {
            break
        } else {
            if(styleMapKey === 'Gem') {
                break // we're done - no need to check anything higher in the prototype chain than Gem
            }

            styleMapKey = nextContructor.name
            nextContructor = nextContructor.parent
        }
    }

    var reversedStyles = styles.reverse() // reverse so later styles override earlier styles
    var styleToReturn = reversedStyles[0]
    for(var n=1; n<reversedStyles.length; n++) {
        styleToReturn = styleToReturn.mix(reversedStyles[n], false)
    }

    return styleToReturn


    function findStylesForStyleMapKey(startAncestor, key) {
        var styles = [], inherit = true
        var curAncestor = startAncestor, nextAncestorToSearchFrom = startAncestor
        while(curAncestor !== undefined) {                                // find styles from the closest parent to the farthest
            if(curAncestor.computedStyleMap !== undefined) {
                var style = curAncestor.computedStyleMap[key]
            }
            if(style !== undefined) {
                if(styles.indexOf(style) === -1) {
                    styles.push(style)
                }
                nextAncestorToSearchFrom = curAncestor

                inherit = style.inherit
                if(!inherit) {
                    break
                }
            }

            curAncestor = curAncestor.parent
        }

        return {styles:styles, nextAncestorToSearchFrom: nextAncestorToSearchFrom, inherit:inherit}
    }
}

// returns the conjunction of two style maps
// gets it from the computedStyles cache if its already in there
var styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {
    if(secondaryStyleMap === undefined) return primaryStyleMap
    if(primaryStyleMap === undefined) return secondaryStyleMap

    var cachedStyleMap = computedStyles.get([secondaryStyleMap, primaryStyleMap])
    if(cachedStyleMap === undefined) {
        if(secondaryStyleMap  === undefined) {
            cachedStyleMap = primaryStyleMap
        } else if(primaryStyleMap === undefined) {
            cachedStyleMap = secondaryStyleMap
        } else {
            var overridingProperties = {}, atLeastOne = false
            for(var key in primaryStyleMap) {
                if(secondaryStyleMap[key] !== primaryStyleMap[key]) {
                    overridingProperties[key] = primaryStyleMap[key]
                    atLeastOne = true
                }
            }

            if(atLeastOne) {
                cachedStyleMap = utils.objectConjunction(secondaryStyleMap, overridingProperties)
            } else { // the styleMaps are different objects, but contain the same thing
                cachedStyleMap = secondaryStyleMap
            }
        }

        if(cachedStyleMap === undefined) cachedStyleMap = false // switch it out with false so it can be recognized
        computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)
    }

    if(cachedStyleMap === false) {
        return undefined
    }
    return cachedStyleMap
}



exports.getDefaultStyle = function(gem)  {
    // attempt to get from the cache
    var defaultGemStyle = defaultStyleMap.get(gem.constructor)
    if(defaultGemStyle === undefined) {
        defaultGemStyle = createDefaultGemStyle(gem)
        if(defaultGemStyle === undefined) defaultGemStyle = false
        defaultStyleMap.set(gem.constructor, defaultGemStyle)
    }

    if(defaultGemStyle === false) {
        return undefined
    }
    return defaultGemStyle
}

// returns a new style with style b mixed into style a (works even if they're both undefined)
var mixStyles = exports.mixStyles = function(a,b) {
    if(a === undefined)
        return b
    else
        return a.mix(b, false)
}





// sets the currentStyle of a gem and makes all the appropriate changes to render a new active style for the gem and its children
exports.setCurrentStyle = function(gem, newCurrentStyle, defaultStyle) {

    var current$state = gem._currentStyle === undefined? undefined: gem._currentStyle.stateHandler
    var newCurrentStyle$state = newCurrentStyle === undefined? undefined: newCurrentStyle.stateHandler
    if(current$state !== newCurrentStyle$state) {     // if the $state function remains the same, we don't gotta do nothin (about switching state functions at least)
        if(gem._stateChangeHandler !== undefined) {  // remove the old handler if necessary
            gem.state.removeListener('change', gem._stateChangeHandler)
            gem._stateChangeHandler = undefined
        }

        if(newCurrentStyle$state !== undefined) {     // add a new handler if necessary
            gem.state.on('change', gem._stateChangeHandler = function() {
                var rawStateStyle = getStateStyle(gem._currentStyle, gem.state.subject)
                setMixedStateStyle(gem, mixStyles(gem._currentStyle, rawStateStyle))
            })
        }
    }

    gem._currentStyle = newCurrentStyle
    var rawStateStyle = getStateStyle(newCurrentStyle, gem.state.subject)

    var newMixedStateStyle = mixStyles(newCurrentStyle, rawStateStyle)
    setMixedStateStyle(gem, newMixedStateStyle, defaultStyle)
}


// handles reseting a gem's active style when its state style changes
// renders the pseudoclass style
function setMixedStateStyle(gem, mixedStateStyle, defaultStyle) {
    var psuedoclassState = {}

    // if a pseudoclass can no longer apply, undo its setup
    for(var pseudoClass in gem._styleSetupInfo) {
        if(mixedStateStyle === undefined || !(pseudoClass in mixedStateStyle.pseudoclasses.emulatedInfo)) {
            var setupInfo = gem._styleSetupInfo[pseudoClass]
            setupInfo.kill(gem, setupInfo.state)
            delete gem._styleSetupInfo[pseudoClass]
        }
    }

    // setup new pseudoclasses
    if(mixedStateStyle !== undefined) {
        for(var pseudoClass in mixedStateStyle.pseudoclasses.emulatedInfo) {
            if(!(pseudoClass in gem._styleSetupInfo)) {                     // if this exact pseudoclass is already setup, no need to do anything
                ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)
                    var setupState = emulationInfo.fns.setup(gem, function() { // start
                        var changed = psuedoclassState[pseudoClass] !== true
                        if(changed) {
                            psuedoclassState[pseudoClass] = true
                            changeStyleIfNecessary()
                        }
                    }, function() { // end
                        var changed = psuedoclassState[pseudoClass] !== false
                        if(changed) {
                            psuedoclassState[pseudoClass] = false
                            changeStyleIfNecessary()
                        }
                    }, emulationInfo.parameter)

                    gem._styleSetupInfo[pseudoClass] = {state: setupState, kill: emulationInfo.fns.kill}

                })(pseudoClass, mixedStateStyle.pseudoclasses.emulatedInfo[pseudoClass])
            }
        }
    }

    // build up the pseudoclass state - depending on what pseudoclasses might become applicable
    if(mixedStateStyle !== undefined) {
        for(var pseudoclassKey in mixedStateStyle.pseudoclasses.emulatedInfo) {
            var info = mixedStateStyle.pseudoclasses.emulatedInfo[pseudoclassKey]
            psuedoclassState[pseudoclassKey] = info.fns.check(gem, info.parameter)
        }
    }

    // set current pseudoclass style
    changeStyleIfNecessary()


    function changeStyleIfNecessary() {
        var pseudoclassStyleInfo = getPseudoclassStyleFor(mixedStateStyle, psuedoclassState)
//        if(pseudoclassStyleInfo.style !== undefined && pseudoclassStyleInfo.style.inherit) {
//            pseudoclassStyleInfo.style = getInheritingStyle(gem).mix(pseudoclassStyleInfo.style, false)
//        }

        var newPreStyleMapStyle = mixStyles(mixedStateStyle, pseudoclassStyleInfo.style)
        setPreStyleMapStyle(gem, newPreStyleMapStyle, pseudoclassStyleInfo.index, defaultStyle)
    }
}

// sets the style before being modified by the gem's parent's computedStyleMap
// handles removing the state listener and calling $kill on the old activeStyle
function setPreStyleMapStyle(gem, newPreStyleMapStyle, jsRenderedPseudoclassIndex, defaultStyle) {
    if(gem.parent !== undefined && newPreStyleMapStyle !== undefined)
        var newComputedStyleMap = styleMapConjunction(gem.parent.computedStyleMap, newPreStyleMapStyle.componentStyleMap)
    else if(gem.parent !== undefined)
        var newComputedStyleMap = gem.parent.computedStyleMap
    else if(newPreStyleMapStyle !== undefined)
        var newComputedStyleMap = newPreStyleMapStyle.componentStyleMap
    else
        var newComputedStyleMap = undefined

    var newActiveStyle = undefined // can be changed below
    var cancel = false
    if(newPreStyleMapStyle !== undefined) {
        if(gem.parent !== undefined) var nativePseudoclassMap = gem.parent._nativePseudoclassMap
        else                           var nativePseudoclassMap = {}

        var nativePseudoclassSelectorMap = getStyleMapEntryForGem(nativePseudoclassMap, gem)
        var nativeCssInfo = newPreStyleMapStyle.createNativeCssInfo(gem, newComputedStyleMap, nativePseudoclassSelectorMap, jsRenderedPseudoclassIndex, defaultStyle)

        if(nativeCssInfo.cancel) {
            cancel = true
            setMixedStateStyle(gem, nativeCssInfo.retryStyle)

        } else {
            newActiveStyle = nativeCssInfo.style
            newComputedStyleMap = nativeCssInfo.styleMap // even newer!
            gem._nativePseudoclassMap = nativeCssInfo.nativePseudoclassMap
        }
    }

    if(!cancel) {
        setActiveStyle(gem, newActiveStyle, newComputedStyleMap)
    }
}

// sets the active style on the gem and on the gem's children
// also sets the gem's new computedStyleMap
function setActiveStyle(gem, newActiveStyle, newComputedStyleMap) {
    var activeStyleChanged = newActiveStyle !== gem._activeStyle
    var computedStyleMapChanged = gem.computedStyleMap !== newComputedStyleMap

    if(activeStyleChanged) {
        setStyleClass(gem, newActiveStyle)

        var curActiveStyle$setup = gem._activeStyle === undefined? undefined: gem._activeStyle.setup
        var newActiveStyle$setup = newActiveStyle === undefined? undefined: newActiveStyle.setup
        if(curActiveStyle$setup !== newActiveStyle$setup) {
            applyStyleKillFunction(gem)
            applyStyleSetupFunction(gem, newActiveStyle)
        }

        gem._activeStyle = newActiveStyle
    }


    gem.computedStyleMap = newComputedStyleMap

    // propogate styles to children
    gem.children.forEach(function(child) {
        if(computedStyleMapChanged || !child.attached) {
            setAttachStatus(child, true)
            child.style = child.style  // force a re-render on each child
        }
    })
}

var setAttachStatus = exports.setAttachStatus = function(node, attached) {
    node.attached = attached
    if(attached) {
        node.emit('attach')
    } else {
        node.emit('detach')
        node.children.forEach(function(child) {
            setAttachStatus(child, false)
        })
    }
}


// given a style and an object representing some state, returns the state given by the style's $state function
// returns undefined if it doesn't have a state function
// handles caching state styles (an optimization)
function getStateStyle(currentStyle, stateParameter) {
    if(currentStyle === undefined || currentStyle.stateHandler === undefined) return undefined

    var returnedStyle = currentStyle.stateHandler(stateParameter)

    // todo: figure out if this style has been returned before, and if so, use the already-generated style (mostly so that that style can take advantage of other cached combinations)

    return returnedStyle
}

// returns an object with the properties:
    // style - the jsRendered pseudoclass style for the gem's relevant pseudoclass state
    // index - the index of the pseudoclass (jsRenderedPseudoclassIndex)
// returns undefined if no emulated pseudoclass style applies or if only native pseudoclass stylings apply
// state - an object that will be mutated with the current state for each pseudoclass
function getPseudoclassStyleFor(style, state) {
    if(style === undefined) return {index:0}

    var index = 0, result={index:0}
    style.pseudoclasses.classes.forEach(function(psuedoclassStyle, compoundKey) {
        if(!psuedoclassStyle.pureNative) {
            for(var j=0; j<compoundKey.length; j++) {
                var pseudoclass = compoundKey[j]
                if(!state[pseudoclass]) {
                    break;
                }
            }

            if(j === compoundKey.length) {
                result = {index: index, style: psuedoclassStyle}
            }
        }

        index++
    })

    return result
}



// finds the default style for a gem, mixes it with the appropriate ancestor styles, and returns the result
function createDefaultGemStyle(that) {
    if(that.defaultStyle !== undefined) {
        var defaultStyle = getStyleObject(that.defaultStyle)
    }

    // get list of default styles
    var defaultStyles = []
    var nextConstructor = that.constructor
    while(nextConstructor !== undefined) {
        if(nextConstructor.defaultStyle !== undefined) {
            defaultStyles.push(nextConstructor.defaultStyle)
        }
        nextConstructor = nextConstructor.parent
    }

    // generate merged default style
    var reversedDefaults = defaultStyles.reverse()
    var mergedDefaultStyle = reversedDefaults[0]
    for(var n=1; n<reversedDefaults.length; n++) {
        mergedDefaultStyle = mergedDefaultStyle.mix(reversedDefaults[n], false)
    }

    return mergedDefaultStyle
}


// applies setup appropriately
function applyStyleSetupFunction(component, style) {
    if(style !== undefined && style.setup !== undefined) {
        component._styleSetupObject = style.setup(component, style) // call setup on the component
    } else {
        component._styleSetupObject = undefined
    }
}
// applies kill appropriately
function applyStyleKillFunction(component) {
    var activeStyle = component._activeStyle
    if(activeStyle !== undefined && activeStyle.setup !== undefined) {
        if(activeStyle.kill === undefined)
            throw new Error('style has been unset but does not have a "kill" function to undo its "setup" function')

        activeStyle.kill(component, component._styleSetupObject)
    }
}


// sets the style, replacing one if one already exists
function setStyleClass(component, style) {
    var activeStyle = component._activeStyle

    //var newStyle = component.domNode.className
    if(activeStyle !== undefined) {
        component.domNode.classList.remove(activeStyle.className)
        // newStyle = newStyle.replace(new RegExp(" ?\\b"+activeStyle.className+"\\b"),'') // remove the previous css class
    }
    if(style !== undefined) {
        component.domNode.classList.add(style.className)
        //newStyle = style.className+' '+newStyle.trim() // note that the order of classes doesn't matter
    }

    //component.domNode.className = newStyle
}

var styleObjectMap = new HashMap // maps javascript object styles to Style objects
var getStyleObject = exports.getStyleObject = function(style) {
    if(isStyleObject(style)) {
        return style
    } else {
        var styleObject = styleObjectMap.get(style)
        if(styleObject) {
            return styleObject
        } else {
            var styleObject = Style(style)
            styleObjectMap.set(style,styleObject)
            return styleObject
        }
    }
}

// if you load two different instances of gems, its necessary to do a bit of duck typing
var isStyleObject = exports.isStyleObject = function (x) {
    return x.className !== undefined && x.componentStyleMap !== undefined && x.mix !== undefined
}